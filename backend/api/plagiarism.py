# api/plagiarism.py (UPDATED)
"""
API routes for plagiarism and AI detection
Integrates Winston AI 
"""

import os
import logging
from fastapi import APIRouter, UploadFile, File, HTTPException, Query
from models.schemas import PlagiarismTextRequest

from services.winston_ai_service import WinstonAIService
from services.ai_detector_service import AIDetectorService


logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/ai", tags=["AI Detection"])

# ==================== QUICK AI CHECK ====================

@router.post("/check-ai-only")
async def check_ai_only(
    file: UploadFile = File(...),
    use_api: bool = Query(default=True, description="Use Winston AI API")
):
    """
    AI-only content detection (accepts uploaded file).
    Reads text from the uploaded file and performs AI detection.
    """
    try:
        logger.info(f"[API] AI-only check (file): {file.filename}")

        raw_bytes = await file.read()
        text = raw_bytes.decode("utf-8", errors="ignore")

        if len(text.strip()) < 50:
            raise HTTPException(
                status_code=400,
                detail="File contains too little readable text (minimum 50 characters)."
            )

        # --- Run detection ---
        winston = WinstonAIService()
        result = await winston.detect_ai_content(text)

        # If Winston AI fails â†’ fallback to local Desklib model
        if result.get("status") != "success":
            from services.ai_detector_service import AIDetectorService
            local_detector = AIDetectorService()
            if local_detector.is_service_available():
                logger.info("[API] Falling back to local Desklib AI detector")
                result = await local_detector.check_ai_content(text)
                result["method"] = "Desklib Local Model"  
                is_ai = False
                method_used = "Desklib Local Model"


        if result.get("method", "").lower().startswith("winston"):
            ai_prob = float(result.get("ai_probability", 0.0)) * 100.0   
        else:
            ai_prob = float(result.get("ai_probability", 0.0))         


        # --- Normalize values ---
        ai_prob = max(0.0, min(ai_prob, 100.0))

        # --- Risk level classification ---
        if ai_prob >= 90:
            overall_risk = "very_high"
        elif ai_prob >= 70:
            overall_risk = "high"
        elif ai_prob >= 40:
            overall_risk = "medium"
        else:
            overall_risk = "low"

        logger.info(f"[DEBUG] AI Detection Final Result: {result}")
        logger.info(f"[DEBUG] ai_prob={ai_prob}, is_ai={is_ai}, method={method_used}")

        # --- Final response payload ---
        return {
            "status": "success",
            "filename": file.filename,
            "ai_probability": round(ai_prob, 4),
            "is_ai_generated": is_ai,
            "method": method_used,
            "overall_risk": overall_risk,
            "details": {
                "ai_detection": {
                    "status": result.get("status"),
                    "method": method_used,
                    "probability": ai_prob,
                    "error": result.get("error")
                }
            },
            "recommendations": [
                {
                    "type": "ai_detected" if is_ai else "clean",
                    "severity": overall_risk,
                    "message": (
                        "AI-Generated Content Detected"
                        if is_ai else "Content Appears Human-Written"
                    ),
                    "suggestion": (
                        "This text appears to have been generated by AI. "
                        "Consider rewriting in your own words or adding clear disclosure."
                        if is_ai
                        else "Your text appears authentic and human-written. No action needed."
                    ),
                }
            ],
        }


    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"[API] check-ai-only error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))

    
